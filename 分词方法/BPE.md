## 概述

Byte Pair Encoding (BPE) 是一种**子词分词算法**，最初用于数据压缩（1994），后被引入自然语言处理领域（Sennrich et al., 2015）。其核心思想是通过迭代合并最高频的相邻符号对来构建词汇表，既能处理未登录词(OOV)，又能平衡词表大小与分词粒度。被广泛应用于GPT系列、BERT等模型。

## 技术细节

### 核心原理

给定训练语料，BPE通过以下步骤构建词表：

1. **初始化**：将所有单词拆分为字符序列，并添加结束符\</w\>
   - 例："lower" → \["l","o","w","e","r\</w\>"\]

2. **频率统计**：统计所有相邻符号对的共现频率
   - 统计符号对如("l", "o"),("o","w"),("w","e"),("e","r\</w\>") 等的频率。

3. **合并操作**：迭代合并最高频的符号对
   - 合并频率最高的符号对（如("e", "r\</w\>") → "er\</w\>"）。
   - 更新符号序列变为\["l","o","w","er\</w\>"\]。
   - 更新符号频率表
      - 将合并后的符号频率添加到表中。
      - 将每个子符号的频率减去合并符号的频率。
   - 开始下一轮合并。

4. **终止条件**：重复合并直到达到预设词表大小$V$或合并次数$K$

### 编码解码

**编码过程**：
1. 将单词拆分为字符序列+\</w\>
2. 应用所有可能的合并规则（按合并顺序的倒序应用）
3. 按最长匹配原则进行分词

例：合并规则为("l", "o")→"lo", ("lo", "w\</w\>")→"low\</w\>"
- "low\</w\>" → 直接保留
- "lower\</w\>" → \["low\</w\>", "er\</w\>"\]

**解码过程**：
1. 合并子词并移除\</w\>标记
   - \["low\</w\>", "er\</w\>"\] → "lower"

## 优点和缺点

### 优点
| 优势 | 说明 |
|------|------|
| 平衡词表 | 通过调整合并次数控制词表大小（典型值10k-100k）|
| OOV处理 | 所有单词均可拆分为子词组合 |
| 跨语言兼容 | 统一处理不同语言的字符 |
| 形态学保留 | 自动捕获常见词缀（-ing, -ed等） |
### 3.2 缺点

1. **分割不一致**  
   同一单词在不同位置可能拆分不同：

```python
   "testing" → ["test", "ing"]  # 作为独立词
   "testing" → ["t", "esting"]  # 在长单词中间时可能出现
```

1. **稀有词处理**  
   低频字符可能被过度拆分：

```python
    "Schrödinger" → ["Sch", "r", "ö", "dinger"]
```
    
2. **非最优合并**  
    贪心算法无法回溯，可能优先合并非语义单元：
    
    python
    
    Copy
    
    ("h", "e")比("t", "h")频率更高时，可能先合并"he"而不是"th"
    
3. **解码歧义**  
    不同子词组合可能生成相同表面形式：
    
    python
    
    Copy
    
    ["a", "bc"]和["ab", "c"]都可能解码为"abc"